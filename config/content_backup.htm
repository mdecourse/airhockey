<h1>About</h1>
<p>作者:</p>
<p>張華倞</p>
<p>陳鉅忠</p>
<p>葉修宏</p>
<p>張育偉</p>
<p>本網站是基於 <span>論文-影像辨識在虛實整合機電系統設計之應用整理而成</span></p>
<p>會就以下主題逐步介紹:</p>
<p>文獻探討</p>
<p>設計流程</p>
<p>影像辨識</p>
<p>路徑預測</p>
<p>虛實整合系統</p>
<p></p>
<p></p>
<p></p><h1>Introduction</h1>
<p>In recent years, the integration of image<br/>recognition and virtual reality become more and more<br/>extensive in the mechatronic product development [4-6].<br/>Moreover, due to the rapid progress of Internet<br/>information technology, the impact of virtual and<br/>physical integration technology on product development<br/>becomes more common [19]. This paper developed an<br/>air hockey robot that can be played by human and<br/>computer program to use the image recognition to play<br/>the match.<br/>There are two major different type of air hockey<br/>game design, one use disk puck on an air cushion table<br/>and another use hover puck on any ordinary flat surface<br/>or table. In this research, hover puck design was chosen<br/>to allow air hockey robot to be attached to computer<br/>table of any size.<br/>This research is divided into four parts. The first<br/>step is to create a physical air hockey robot and use<br/>Python program for image recognition to allow the web<br/>camera to catch the position of the hover puck, and<br/>activate the two-degree-of-freedom motion of the mallet<br/>accordingly. The second step is to use CoppeliaSim [2]<br/>to simulate the mechatronic air hockey scene, and the<br/>third part is to use the Flow Simulation functions of<br/>Solidworks and COMSOL to analyze the air cushion<br/>dynamics of the fan blades inside the hover puck.<br/>In the end, the virtual and physical air hockey<br/>scene were streamed into the user web browser to allow<br/>multiple users to monitor or participate into the<br/>cyber-physical game.</p>
<h1>Literature Review</h1>
<h1>Design Process</h1>
<h2>Physical Design</h2>
<h4>Onshape Files:</h4>
<p><a href="https://cad.onshape.com/documents/8ce42d1efd45b3bdb98ba700/w/cc6ad7d5bd934e9ffccd77aa/e/cef09b8fe878e693e76eb618" rel="nofollow">air hockey robot assembly</a></p>
<p></p>
<p>In order to collaboratively design all parts of the X-Y table system to manipulate the planar motion of the mallet, the full cloud computer aided design system, <a href="https://www.onshape.com/">Onshape</a> was used. The motion control of the hockey mallet is implemented by using Arduino、 stepping motors and pulley-belt system to position the mallet.</p>
<p>The designed air hockey <a href="https://www.onshape.com/">Onshape</a> assembly file can be accessed from. The mechatronic simulation of the air hockey machine is completed in <a href="https://www.coppeliarobotics.com/">Coppeliasim</a>.</p>
<p>The design of the hover puck uses the air flow generated by the built-in fan to levitate from the platform to reduce the friction, so that it can move smoothly The control uses the Arduino circuit board to receive the binary data transmitted by the Python module Pyserial for corresponding control, so that the motor can move along X and Y coordinates.</p>
<p>The air hockey robot completed in this research can be assembled on a common computer desk. The hover puck can float on the desk by the downward negative pressure driven by the fan. And the two-degree-of-freedom movement range of the X-Y Table can adapt to the size of the table. In achieving the levitation effect, the hover puck needs three AAA batteries, which are arranged into a triangular layout around the motor to achieve dynamic balance.</p><h2>Program Development</h2>
<p>The image recognition program is written in Python combined with the OpenCV module, and interacts with the virtual environment through the remote api interface of Coppeliasim. The hockey mallet in the physical model is also guided through the same image recognition program. The structure that controls the action of the hockey mallet can be simultaneously used on physical and virtual air hockey game platforms. In order to accurately estimate the speed and direction of the hover puck motion, we calculate the position difference from each image sensor frame in the image recognition program.</p><h1>Image Recognition</h1>
<h2>Color Conversion</h2>
<p>RGB is the three primary colors of light, namely Red, Green and Blue. The image output is mostly in this form, but this method is very difficult to capture a specific color in settings, so it is converted to HSV Display, HSV stands for Hue, Saturation and Value respectively. Use Hue to adjust to the desired color, and then set saturation and lightness.</p>
<p><img caption="false" height="173" src="/images/200px-RGB_Cube_Show_lowgamma_cutout_a.png" width="231"/><img alt="" height="173" src="/images/197px-HSV_color_solid_cylinder_saturation_gray.png" width="231"/></p><h2>Filtration of Color</h2>
<p>Use the values of the three colors contained in each pixel to leave the required range, and remove the rest to get the filtered image. When filtering, give the upper and lower limits of the color range.</p>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr" id="tw-target-text"><span lang="en" mce-data-marked="1">Original image:</span></pre>
<p><img alt="" height="437" src="/images/Rainbow.jpg" width="531"/></p>
<p>After Filtration:<span> </span></p>
<p><span>Filtration Range: (90,50,50)~(110,255,255)</span></p>
<p><img alt="" height="438" src="/images/Rainbow_color.jpg" width="533"/></p>
<p>Code:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import cv2, numpy

img = cv2.imread('Rainbow.jpg')
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
range = 10
lower_color = numpy.array([100-range,50,50])
upper_color = numpy.array([100+range,255,255])
mask = cv2.inRange(hsv, lower_color, upper_color)

cv2.imshow('My Image', mask)
cv2.waitKey(0)
cv2.destroyAllWindows()</pre>
<p></p><h2>Noise Removal Process</h2>
<p>When using a webcam to take pictures in real time, the image will accompany with noise due to the propagation of electronic signals or other external factors. This noise is likely to cause a lot of unnecessary output during image processing, so it is necessary to perform noise filtering to prevent affecting the accuracy of the output results. The image noise filtering in this paper has two steps, that is, first mask the noise and then remove the mask noise. Noise masking algorithms mainly use thresholding and segmentation according the color of the hover puck.</p>
<p>Orginal image:</p>
<p><img alt="" height="438" src="/images/Rainbow_color.jpg" width="533"/></p>
<p>After Noise Removal:</p>
<p><img alt="" height="439" src="/images/Rainbow_Noise%20Removal.jpg" width="532"/></p>
<p>Code:</p>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">import cv2, numpy

img = cv2.imread('Rainbow.jpg')
hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
range = 10
lower_color = numpy.array([100-range,50,50])
upper_color = numpy.array([100+range,255,255])
mask = cv2.inRange(hsv, lower_color, upper_color)

kernel = numpy.ones((7,7),numpy.uint8)
mask2 = cv2.morphologyEx(mask, cv2.MORPH_OPEN, kernel)

cv2.imshow('My Image', mask2)
cv2.waitKey(0)
cv2.destroyAllWindows()</pre>
<p></p><h2>Adjustment of Image</h2>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="en">The coordinates are obtained from the image,<br/></span><span lang="en">so the x y plane's correction is very important.<br/><br/>Cause the reasons, it's hard to be accurate.<br/>1. </span><span lang="en"><span>It is difficult to make the webcam be perpendicular to the table.</span></span><span lang="en"><br/>2. T</span><span lang="en"><span>he coordinate value is </span></span><span lang="en"><span>easily </span></span><span lang="en"><span>affected by </span></span><span lang="en">the v<span>ibration.</span></span></pre>
<pre class="tw-data-text tw-text-large XcVN5d tw-ta" data-placeholder="翻譯" dir="ltr"><span lang="en"><span>So we use the yellow point which is on the table to adjust the image.<br/><br/></span><br/></span><span lang="en"><br/><br/></span></pre>
<p><iframe allowfullscreen="allowfullscreen" height="314" src="//www.youtube.com/embed/IaUenPFhgf4" width="560"></iframe></p><h1>Path Prediction</h1>
<h2>Translational Velocity of the Air Puck</h2>
<h2>Linear Movement</h2>
<h2>Rebound Calculation</h2>
<h1>Cyber-Physical Mechatronic System</h1>